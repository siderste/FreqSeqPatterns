!input data source
storage = hdfs://localhost:9000/input
!storage = hdfs://snf-7479/user/spark/stelios
! storage = /home/stylianos/Desktop/disk/infolab/phd/working/Semantic Pattern Mining/runs/datasets
! storage = /home/stylianos/Desktop/disk/infolab/IdeaProjects/FreqSeqPatterns/input
! data_file = aviation_693_lebl2lemd_corrected_route_wday_wcateg-tocluster.csv
data_file=a1day4class100objs.csv
!data_file=trajs/trajs/*
! A_4_day_scenario_4_class_400_del.csv
! aviation_693_lebl2lemd_corrected_route_wday_wcateg-tocluster_100.csv
results = hdfs://localhost:9000/results
! delimiter , ;
delimiter=,

! multidimensional parameters of the input, format is [trajectory-id; d1; d2; d3; d4; ........]
! d1 gives the timestamp in Long (e.g. secs or millis) which should start from 0 to .... for every trajectory
! thus the (d_0, d_1) columns are the key of the dataset (no duplicates here!!!)
! d2,d3,d4 may be the x,y,z dimensions and d5,.... may be numerical dimensions and then nominal dimensions

! MIND types are hard-coded in code (e.g. class definitions etc). Allowed values are L,D,S
dimensionTypes=L,L,D,D,D,S,S,S,D,D
! which dimensions are to be used in finding semantic areas
selectedDimensions=0,0,0,0,0,0,1,1,0,0
! MIND units of measure to agree with input's, also a value fo all dims is needed despite taking into account
cellSizePerDim=1,1,10000,10000,3000,1,1,1,5,10

!clustering parameters
! method to get semantic areas [MSLSH, MINHASHLSH, CELLS, BISECTING, PATCHWORK, DBSCAN, HOTSPOT, MERGINGCELLS]
semAreasMethod = MINHASHLSH

!MINHASHLSH
!number of hash tables for LSH, b bands or amplify
numOfHashTables=5
lshJoinThreshold=0.5

!PrefixSpan parameters
minSupport=0.3
maxPatternLength=100
maxLocalProjDBSize=32000000
maxDTofPatterns=800

!LocalMeanShift
maxIterationAreas = 100
mergeWindowAreas = 0.001
!the lshJoinThreshold
bandwidthAreas = 0.5

maxIteration = 100
mergeWindow = 0.001
bandwidth = 10000






!hotspot
neighborDistanceInCells=3
outputNumberHotSpots=50
weightFactor=2

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
!BISECTING
!distanceMethod between two vector points [euclidean, cosine, jaccard, RV]
bskm_distanceMethod=cosine
! number of clusters needed
bskm_k=20
! number of max iterations
bskm_maxIterations=100
!minimum elements of a cluster to be divisible
bskm_minDivisibleClusterSize=10

!MSLSH
! using binary vector instead of vectors of doubles
ms_binary_vectors=true
!number of neighbours to look at during gradient ascent
ms_k=4
!threshold under which we stop iteration in gradient ascent
ms_epsilon1=0.07
!threshold under which we give the same label to two points
ms_epsilon2=0.05
!threshold under which we give the same label to two close clusters
ms_epsilon3=0.07
!% of data that have NOT converged in order to stop iteration in gradient ascent
ms_ratioToStop=1.0
!Number of iteration for modes search
ms_yStarIter=5
!threshold under which we fusion little cluster with the nearest cluster
ms_cmin=1
!Normalise the dataset (it is recommand to have same magnitude order beetween features)
ms_normalisation=true
!regularisation term, default = 1
ms_w=1
!number of segment on which we project vectors ( make sure it is big enought )
ms_nbseg=7
!number of buckets used to compute modes
ms_nbblocs1=7
!number of buckets used to fusion clusters
ms_nbblocs2=1
!number of iteration for the labelisation step, it determines the number of final models
ms_nbLabelIter=1

!PATCHWORK
!epsilonFlag = 500.0,500.0,500.0 ! for 3 dimensions, must be of same metrics per dimension
epsilonFlag = 1,1,10000,10000,3000,50,50,50,35,1,1
! minPtsFlag >= number of points in a cell
minPtsFlag = 1
! minCellInClusterFlag > number of cells in a cluster
minCellInClusterFlag = 0
! if near cell has same number of points set 1, if has the half set 0.5 etc
ratioFlag = 1

!postgresql database
dbHost=localhost
dbSchema=postgres
tableClusters=spark_patchwork_clusters_synopses_run1